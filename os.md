# 计算机操作系统

# CH1 操作系统引论 

**操作系统的工作**

1. 程序的执行
2. 完成与硬件有关的工作
3. 完成与硬件无关的工作
4. 计算机系统的效率与安全问题

<img src="./os.assets/image-20221127102714678.png" alt="image-20221127102714678" style="zoom: 50%;" />

## OS的目标和作用

### OS的目标

- **方便性**	使计算机更容易使用
- **有效性**	提高CPU IO设备利用率、组织工作流程（架构与算法）
- 可拓展性
   如何才有可扩充性？
  - 采用层次结构
  - 扩展=模块+层次
- 开放性

### OS的作用

- OS作为用户和计算机硬件系统的接口
- OS作为计算机资源的管理者
- OS实现了对计算机资源的抽象

**OS作为用户和计算机硬件系统的接口**

用户可以通过..使用计算机

- 命令方式
- 图标、窗口方式（GUI）
- 系统调用方式（程序接口）

<img src="./os.assets/image-20221127104612372.png" alt="image-20221127104612372" style="zoom:33%;" />

**OS作为计算机资源的管理者**

资源可以分为四类

- 处理器
- 存储器
- I/O设备
- 信息（数据和程序） 

**OS实现了对计算机资源的抽象**

虚拟性是SO的基本特征之一

> Q：如何实现OS的虚拟性
>
> Ans：抽象硬件资源

## OS的发展过程

20c50	第一个简单的批处理系统
20c60	多道程序批处理系统，分时系统
20c80-90 微型机、多处理机、计算机网络大发展年代→微机OS、多处理机OS和网络OS的形成和大发展年代

### 无OS的计算机系统

- 人工操作方式（打孔纸带）
  - 用户独占全机
  - CPU等待人工操作
- 脱机输入/输出方式
  本质就是把输入提前放到磁带机，主机输出也放到磁带机
  - 减少CPU的空闲时间
  - 提高了I/O速度<img src="./os.assets/image-20221127111445602.png" alt="image-20221127111445602" style="zoom:33%;" />

###  单道批处理系统

是OS的前身

把**一批作业**以脱机方式输入到磁带上
在监督程序的控制下使得这批作业**一个接一个**地连续处理

### 多道批处理系统

用户提交的作业事先放在外村上，形成“后备队列”
作业调度程序按照一定算法从后备队列中**选择若干作业**调入内存（不一定是顺序调入）

- 提高CPU利用率	原因：运行程序A时候，利用其因I/O操作时的CPU空档时间，再调度另一道程序B
- 提高内存和I/O设备的利用率
- 增加系统吞吐量

**特征**

- 多道性	多道程序在内存中并发执行
- 无序性	根据作业调度算法决定调用的先后顺序
- 调度性	作业提交到完成，经过两种调度：作业调度和进程调度

**优点**

- 资源利用率高
- 系统吞吐量大 系统吞吐量是指系统在单位时间内所完成的总工作量

**缺点**

- 平均周转时间长	作业周转时间是指从作业进入系统（提交）开始，直至它完成并退出系统为止所经历的时间
- 无交互能力

### 分时系统

指在一台主机上连接多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。 

**关键问题**
因为有很多用户，必须做到及时

- 及时接收
- 及时处理

**特征**

- 多路性	一台主机连接多个终端
- 独立性	终端彼此独立
- **及时性**	用户请求在很短时间内获得响应
- 交互性	用户通过终端与系统进行广泛的对话

### 实时系统

指系统能及时响应外部事件的请求，在规定时间内完成该事件的处理，并控制所有实时任务协调一致地运行。

**应用需求**

1. 实时控制
2. 实时信息处理

### 实时系统

实时系统与分时系统特征的比较 

1. 多路性	实时系统的多路性主要表现在：系统经常对多路的现场信息进行采集，以及对多个对象或多个执行机构进行控制。 
2. 独立性	实时系统中对信息的采集和对对象的控制，也都是彼此互不干扰 
3. 及时性	实时系统的及时性，是以控制对象所要求的开始截止时间或完成截止时间来确定的。**一般为秒级、百毫秒级直至毫秒级，甚至有的要低于100微秒。** 
4. 交互性	实时系统的交互性仅限于访问系统中某些特定的专用服务程序，不象分时系统那样能向终端用户提供数据处理服务、资源共享等服务。 
5. 可靠性	实时系统要求**系统高度可靠**，往往采用多级容错措施来保证系统的安全性及数据的安全性。 

## 操作系统的基本特征

1. 并发（Concurrence） 
2. 共享（Sharing） 
3. 虚拟（Virtual） 
4. 异步（Asynchronism）

### 并发 

**最重要的特征，其他三个都是以并发为前提的**

<font color=red>**并行与并发**</font>

并行性——两个或多个事件在**同一时刻**发生。 
并发性——两个或多个事件在**同一时间间隔**内发生。 

​    在多道程序环境下，并发性是指在一段时间内，**宏观上有多个程序在同时运行**，但在**单处理机系统中，每一时刻却只能有一道程序执行**，故微观上这些程序只能是**分时地交替执行**。若计算机系统中有多个处理机，则这些可以并发执行的程序可被分配到多个处理机上，实现并行执行。

<font color=red>并发是通过单通道交替执行实现的</font>

**进程**
与并发紧密相连的概念

是指在系统中能独立运行并作为资源分配的基本单位，它是由**一组机器指令、数据和堆栈**等组成的，是一个**活动实体**。

通常的程序是静态实体，它是不能并发执行的。为了使程序能并发执行，系统必须分别为每个程序建立进程（Process)

多个进程之间可以并发执行和交换信息

### 共享

共享是指系统中的资源可供内存中多个并发执行的进程（线程）共同使用。 

**资源共享方式**

1. 互斥共享方式
   1. 临界资源要求被互斥地共享
      **临界资源**是指每次仅允许一个进程访问的资源（例如打印机、消息缓冲队列、变量、数组）
2. 同时访问方式
   1. 对于共享资源
   2. **“同时”往往是宏观上的**，而微观上，这些进程可能是**交替地**对该资源进行访问

### 并发与共享的关系

是操作系统的两个最基本的特征
是互为存在条件的

资源的共享是**以进程的并发执行为条件的**，若系统不允许程序并发执行，自然不存在资源共享问题； 
若系统**不能对资源共享实施有效管理**，协调好诸进程对共享资源的访问，**也必然影响到程序并发执行的程度，甚至根本无法并发执行。** 

### 虚拟

虚拟——是指通过某种技术把一个物理实体变为若干个逻辑上的对应物

OS中利用了多种虚拟技术，分别用来实现虚拟处理机、虚拟内存、虚拟外部设备和虚拟信道等。 

例：

- 利用多道程序设计技术，把一台物理上的CPU虚拟为**多台逻辑上的CPU**，也称为**虚拟处理机**。 
- 利用虚拟存储技术，将一台机器的**物理内存变为虚拟存储器**，以便在逻辑上扩充存储器的容量。 
- 通过虚拟设备技术，将一台物理I/O设备虚拟为多台逻辑上的I/O设备(如，Apple远程光盘)，允许每个用户占用一台逻辑上的I/O设备，这样便可使原来在一段时间仅允许一个用户访问的设备（即临界资源），变为在**一段时间内允许多个用户同时访问的共享设备**。例如，虚拟打印机。 

### 异步

​    内存中的每个进程在何时能获得处理机运行，何时又因提出某种资源请求而暂停，以及进程以怎样的速度向前推进，每道程序总共需要多少时间才能完成等等，都是不可预知的
​	很可能是先进入内存的作业后完成，而后进入内存的作业先完成，或者说，进程是以人们不可预知的速度向前推进，此即进程的异步性。 

## 操作系统的主要功能

### 处理机管理

在传统的多道程序设计系统中，处理机的分配和运行，都是以进程为基本单位的
在引入线程的OS中，还包含对线程的管理

- 进程控制	创建和撤销进程（线程）
- 进程同步	对诸进程（线程）的运行进行协调
- 进程通信	实现进程（线程）之间的信息交换
- 进程调度（处理机调度）	按照一定的算法把处理机分配给进程（线程）

### 存储器管理

- 内存分配 (静态 、动态分配方式 )
- 内存保护 (硬件检查越界（segment fault）,软件处理)
- 地址映射 (逻辑、物理地址，硬件支持)
- 内存扩充 (虚拟存储技术)

### 设备管理

**任务**

- 完成进程提出的I/O请求；
- 为用户进程分配其所需的I/O设备；
- 提高CPU和I/O设备的利用率；
- 提高I/O速度；
- 方便用户使用I/O设备。

**功能**

- 缓冲管理
  在设备和CPU之间引入缓冲，可有效地缓和CPU和I/O设备速度不匹配的矛盾（硬盘是影响整体速度的一个重要原因），提高CPU的利用率，进而提高系统的吞吐量
- 设备分配
- 设备处理（设备驱动程序）

### 文件管理

功能

- 文件存储空间的管理
- 目录管理
- 文件的读/写管理和保护

## 操作系统的结构设计

传统的操作系统结构

- 第一代的OS是无结构的 
- 第二代OS采用了模块式结构 
- 第三代OS是层次式结构 

20世纪90年代中期后

- 第四代OS采用微内核结构 

### **微内核OS结构——现代OS结构** 

微内核结构能有效地支持多处理机运行，故非常使用于分布式系统环境

在与微内核技术发展的同时，**客户/服务器技术**、**面向对象技术**也在迅速发展，把它们应用到基于微内核结构的OS中，便具有了**以微内核为OS核心，以客户/服务器为基础，并且采用了面向对象的程序设计方法的特征。** 

**微内核技术**

- 微内核运行在核心态； 
- 开机后常驻内存（这就是为什么有程序调试有段错误）； 
- **并非一个完整的OS**，而只是为构建通用OS提供一个重要基础； 
- 常采用客户/服务器模式，OS的大部分功能和服务，都由若干服务器提供。 （这就是我们看到Windows中有各种service）

# CH2 进程的控制与描述

## 进程的基本概念

### 前驱图和顺序执行

**顺序执行有两层含义：**

- 外部顺序性
  对于多个用户程序来说，所有程序是依次执行的。
- 内部顺序性
  对于一个程序来说，它的所有指令是按序执行的。

**顺序程序执行的特征**

1. 顺序性
2. 封闭性
   1. 程序运行时独占全机资源，资源的状态（除初始态外）只有本程序才能改变它。
   2. 程序一旦开始执行，其执行结果不受外界影响。 
3. 可再现性

**程序并发有两层含义**

- 内部顺序性
  对于一个程序来说，它的所有指令是按序执行的。
- 外部顺序性
  对于多个程序来说，是交叉执行的。

<font color="red">只有不存在前趋关系的程序之间才有可能并发执行</font>

**并发执行的特征**

1. 间断性
2. 失去封闭性
   程序在并发执行时，由于多个程序共享系统资源，因而这些资源的状态将由多个程序来改变，致使程序的运行已失去了封闭性。 
3. 不可再现性

## 进程

### 进程的组成

**PCB**

![image-20230105221405063](./os.assets/image-20230105221405063.png)

#### **进程的组织方式**

- 链接方式<img src="./os.assets/image-20230105213026219.png" alt="image-20230105213026219" style="zoom: 33%;" />
- 索引方式<img src="./os.assets/image-20230105213053343.png" alt="image-20230105213053343" style="zoom: 33%;" />

<font color=red>PCB是进程存在的唯一标志</font>

### **进程的状态**

- 创建态 创建完成后便进入就绪态
- 就绪态
- 运行态 进程在CPU上运行
- 阻塞态
  在进程运行的过程中，可能会请求等待某个事件的发生。在这个事件发生之前，进程无法继续往下执行，此时操作系统会
  让这个进程下CPU，并让它进入“阻塞态”
- 终止态 执行exit系统调用

#### **进程状态的转换**

![image-20230105212938701](./os.assets/image-20230105212938701.png)

### **什么是进程控制**

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现
进程状态转换等功能。

使用原语来实现进程控制

原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。
可以用“**关中断指令**”和“**开中断指令**”这两个特权指令实现原子性

#### **进程控制相关原语**

**进程创建**

![image-20230105220950203](./os.assets/image-20230105220950203.png)

**进程终止**

![image-20230105221007866](./os.assets/image-20230105221007866.png)

**进程的阻塞和唤醒**

![image-20230105221234769](./os.assets/image-20230105221234769.png)

**进程的切换**

![image-20230105221453772](./os.assets/image-20230105221453772.png)

### 进程通信

#### 共享存储

**基于存储区**：各个应用对共享存储区的访问应该是互斥的

<img src="./os.assets/image-20230109220524346.png" alt="image-20230109220524346" style="zoom:50%;" />

**基于数据结构**

比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式

#### 消息传递

通过操作系统提供的“发送消息/接收消息”原语进行数据交换

- 直接通信方式
  <img src="./os.assets/image-20230109220918310.png" alt="image-20230109220918310" style="zoom:50%;" />
- 间接通信方式
  <img src="./os.assets/image-20230109220939227.png" alt="image-20230109220939227" style="zoom:50%;" />

#### 管道通信

只支持半双工通信
如果要实现双向通信，则需要两个管道

当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程
当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程

管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常
有两种解决方案：

1. 一个管道允许多个写进程，一个读进程
2. 允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux的方案）

### 线程

线程是处理机的调度单位

#### **为什么要引入线程？**

<img src="./os.assets/image-20230109221159327.png" alt="image-20230109221159327" style="zoom:50%;" />

可以理解为轻量级进程

线程是一个基本的CPU执行单元，也是程序执行流的最小单位

引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务

引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）

**线程**则作为**处理机的分配单元**

#### 线程的属性

- 线程是处理机调度的单位
- 多CPU计算机中，不同线程可占用不同的CPU
- 每个线程都有一个线程ID，线程控制块（TCB）
- 线程也有就绪、运行、阻塞三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程，共享进程资源
- 同一进程间的线程的通信无需系统干预
- 同一进程的线程的切换，不会影响进程的切换，**开销比较小**
- 不用进程的线程间的切换，会引起进程切换，**系统开销大**

#### 实现方式

**用户级线程**

![image-20230109222447374 ](./os.assets/image-20230109222447374.png) 

**内核级线程**

管理工作由操作系统完成

内核级线程的切换在核心态下才能完成

操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块），通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”

**优点**：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
**缺点**：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

![image-20230109222546540](./os.assets/image-20230109222546540.png)

#### 多线程模型

**一对一**

一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程

**优点**：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
**缺点**：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

<img src="./os.assets/image-20230109222751441.png" alt="image-20230109222751441" style="zoom:33%;" />

**多对一**

多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。

**优点**：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
**缺点**：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

操作系统只“看得见”内核级线程，因此<font color="red">只有内核级线程才是处理机分配的单位。</font>

<img src="./os.assets/image-20230109222834082.png" alt="image-20230109222834082" style="zoom:33%;" />

**多对多**

n用户及线程映射到m个内核级线程（n >= m）。每个用户进程对应m个内核级线程。

克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用线程库 户进程占用太多内核级线程，开销太大的缺点。

<img src="./os.assets/image-20230109222957985.png" alt="image-20230109222957985" style="zoom:33%;" />

#### 线程的状态与转换

<img src="./os.assets/image-20230109223143143.png" alt="image-20230109223143143" style="zoom:50%;" />

#### **线程的组织**

**线程控制块 TCB** (Thread Control Block)

<img src="./os.assets/image-20230109223215337.png" alt="image-20230109223215337" style="zoom:50%;" />

<img src="./os.assets/image-20230109223232754.png" alt="image-20230109223232754" style="zoom:33%;" />

### 调度

#### 处理机调度	

**调度的三个层次**

1. 高级调度（作业调度）
2. 低级调度（内存调度）
3. 中级调度（进程调度）
   挂起

三层调度的联系与对比

**七状态模型**

#### 进程调度时机、切换与过程、方式

**进程调度（低级调度）的时机**

进程调度是按照某种算法从就绪队列中选择一个进程为其分配处理机

需要进行进程调度与切换的情况

1. 当前进程主动放弃
2. 当前进程被动放弃

进程在操作系统内核程序临界区中不能进行进程调度与切换

**进程的切换与过程**

进程调度方式

#### 调度器/调度程序

调度时机——什么事件会触发“调度程序”？

非抢占式

抢占式

**闲逛进程**

#### 调度算法的评价指标

**CPU利用率**

$利用率=\frac{忙碌的时间}{总时间}$

**系统吞吐量**

单位时间内完成的作业的数量

$系统吞吐量=\frac{总共完成了多少道作业}{总共花了多少时间}$

**周转时间**

从作业被提交给系统开始，到作为完成为止的这段时间间隔

$平均周转时间=\frac{作业周转时间之和}{作业数量}$

$带权周转时间=\frac{作业周转时间}{作业实际运行的时间}$

周转时间与带权周转时间都是越小越好

**等待时间**

**响应时间**

### 调度算法

**先来先服务（FCFS）**

**短作业优先（SJF）**

**高响应比优先（HRRN）**

**时间片轮转（RR）**

适用于分时操作系统

时间片太大，则会退化为先来先服务算法，增大进程响应时间
时间片太小，会导致进程频繁切换，系统花在切换进程的时间上增多，实际执行时间变短

**优先级调度算法**

**多级反馈队列调度算法**

1. 设置多级就绪队列，优先级从高到低，时间片从小到大
2. **新进程**到达时先进入**第1级队列**，按**FCFS**原则排队等待被分配时间片。若用完时间片进程还**未结束**，则进程进入**下一级队列队尾**。如果此时**已经在最下级的队列**，则重新放回**最下级队列队尾**。
3. 只有k级队列为空时，才会为k+1级对头的进程分配时间片
4. 被抢占处理机的进程放到原进程的队尾

优点

- 对各类型进程相对公平(FCFS的优点)
- 每个新到达的进程都可以很快就得到响应(RR的优点)
- 短进程只用较少的时间就可完成(SPF的优点)
- 不必实现估计进程的运行时间(避免用户作假)
- 可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/0密集型进程
- (拓展:可以将因I/0而阻塞的进程重新放回原队列，这样I/0型进程就可以保持较高优先级)

缺点

可能会导致饥饿